#!/bin/env python

import hashlib
import os
from pathlib import Path
from random import randrange
import re
import shutil
import subprocess
import tempfile
import xml.etree.ElementTree as ET

import parse_plist

# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.zip
# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.tar.gz

agent_jar = "tools/jacoco-0.8.12/lib/jacocoagent.jar"
cli_jar   = "tools/jacoco-0.8.12/lib/jacococli.jar"
junit_jar = "tools/junit-5/junit-platform-console-standalone-1.11.4.jar"

def get_problems(location):
    problems = []
    for root, folders, files in os.walk(location):
        for file in files:
            if file.endswith('.fzn'):
                path = Path(root) / Path(file).stem
                test = Path(os.path.sep.join(path.parts[-3:]))
                print("Test", test)
                problems.append(test)
    return problems

def get_random_selection(n, problems):
    selection = []
    for i in range(n):
        selection.append(problems[randrange(len(problems))])
    return selection

def generate_coverage_report(problem, jacop_root, report_storage, store):
    # See: src/test/fz/listchoosegenerator.sh
    # Generates problems into a 'mizincbasedchosen/list.txt'.
    # We don't use this script, but instead generate tests
    # into the list by our own method, but execute them as
    # if generated by that script.
    problem_list     = jacop_root / 'src/test/fz/mizincbasedchosen/list.txt'
    problem_list_bak = problem_list.parent / 'list.txt.bak'

    # Save distributed defaults.
    if Path(problem_list).exists() and not Path(problem_list_bak).exists():
        shutil.copy2(problem_list, problem_list_bak)

    # Write single problem to list.
    with open(problem_list, 'w') as f:
        f.write(str(problem) + os.linesep)

    # Run tests with jacocoagent to get 'jacoco.exec'.

    destfile = "jacoco.exec"
    output   = "report"

    jacoco_options = [
        "output=file",
        "destfile=" + destfile
    ]
    target_classes      = 'target/classes'
    target_test_classes = 'target/test-classes'
    junit_options = [
        "--class-path",
        ":".join([target_classes, target_test_classes]),
        "--select-class",
        "org.jacop.MizincBasedChosen"
    ]
    cmd = " ".join([
        "java",
        "-javaagent:" + agent_jar + "=" + ",".join(jacoco_options),
        "-jar",
        junit_jar,
    ] + junit_options)#  + " " + " ".join(junit_options)
    subprocess.run(cmd, shell = True, cwd = str(jacop_root))

    # Generate report using jacococli.

    cmd_jacoco_cli = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        destfile,
        "--html",
        output,
        "--sourcefiles",
        "src/main/java",
        "--classfiles",
        target_classes
    ])
    subprocess.run(cmd_jacoco_cli, shell = True, cwd = str(jacop_root))
    
    store_at = report_storage / problem
    print("Store report", store_at)
    store_at.mkdir(parents = True)

    # TODO: Extract info from report and don't save report. (Only need execfile and methods.)
    
    shutil.copytree(jacop_root / 'report', store_at / 'report')
    shutil.copy2(jacop_root / 'jacoco.exec', store_at / 'jacoco.exec')

    # Extract and store coverage information.
    store.store_report(problem, store_at / 'report')
    store.summarize()

def main():

    # NOTE
    # Prior to running this script,
    # make sure to run 'mvn compile'
    # and 'mvn test-compile' in
    # targeted jacop distribution.

    store          = CoverageStore(Path('coverage_store'))
    report_storage = 'reports'
    accept_test_p  = lambda p: not (Path(report_storage) / p).exists()

    dist      = Path('jacop-4.10.0')
    category  = 'upTo5sec'
    location  = 'src/test/fz/' + category
    problems  = get_problems(dist / location)

    if not (dist / 'tools').exists():
        shutil.copytree('tools', dist / 'tools')

    # Select tests at random in the beginning
    # to try to avoid bias in case we don't
    # have time to run all. However, when we
    # can't find a test to run after N random
    # selections, do a linear search starting
    # from a random index.

    n = 1
    while n > 0:
        found = False
        # Try run one at random.
        for i in range(10):
            problem = get_random_selection(1, problems)[0]
            if accept_test_p(problem):
                print("Select problem", problem)
                generate_coverage_report(problem, dist, report_storage, store)
                found = True
                break
        if not found:
            # Split sequence at random point.
            x = randrange(len(problems))
            print("Defaulting to sequential search starting at index", str(x))
            # Search first half.
            for i in range(x):
                problem = problems[i]
                if accept_test_p(problem):
                    print("Select problem", problem)
                    generate_coverage_report(problem, dist, report_storage, store)
                    found = True
                    break
            if not found:
                # Search second half.
                for i in range(x, len(problems)):
                    problem = problems[i]
                    if accept_test_p(problem):
                        print("Select problem", problem)
                        generate_coverage_report(problem, dist, report_storage, store)
                        found = True
                        break
        if not found:
            print("Coverage is complete.")
            break
        n = n - 1

def jacoco_report(exec_file, output_location, jacop_dist_location):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        str(exec_file),
        "--html",
        str(output_location / 'report'),
        "--sourcefiles",
        str(jacop_dist_location / "src/main/java"),
        "--classfiles",
        str(jacop_dist_location / "target/classes")
    ])
    subprocess.run(cmd, shell = True)

def jacoco_merge(src_1, src_2, dst):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "merge",
        str(src_1),
        str(src_2),
        "--destfile",
        str(dst)
    ])
    subprocess.run(cmd, shell = True)

def find_sub_suite(storage, jacop_dist_location):

    # Trade-off between time and coverage.
    # Only include a test if it gives a significant
    # coverage boost as defined by this threshold.
    #
    # TODO: Needs calibration.
    #
    coverage_to_time_threshold = 1

    # Files already merged into suite.
    included = set()
    excluded = set()
    suite_initial_location = Path('suite')
    suite_initial_include_file = suite_initial_location / 'include.txt'
    suite_initial_exclude_file = suite_initial_location / 'exclude.txt'
    if suite_initial_location.exists():
        with open(suite_initial_include_file, 'r') as f:
            for line in f:
                print("Init included", line)
                included.add(line.strip())
        with open(suite_initial_exclude_file, 'r') as f:
            for line in f:
                print("Init excluded", line)
                excluded.add(line.strip())

    #print("Initial included", included)
    #print("Initial excluded", excluded)

    options = []
    for root, folders, files in os.walk(storage):
        for file in files:
            if file == 'jacoco.exec':
                problem = os.path.sep.join(Path(root).parts[-3:])
                path    = Path(root) / file
                print("Test problem", problem)
                if not (problem in included or problem in excluded):
                    options.append((problem, path))

    with tempfile.TemporaryDirectory() as temp:
        suite_location = Path(temp) / 'suite'
        candi_location = Path(temp) / 'candi'

        suite     = suite_location / 'jacoco.exec'
        candidate = candi_location / 'jacoco.exec'

        include_file = Path(temp) / 'include.txt'
        exclude_file = Path(temp) / 'exclude.txt'

        if suite_initial_location.exists():
            shutil.copytree(suite_initial_location, suite_location)
            shutil.copy2(suite_location / 'include.txt', include_file)
            shutil.copy2(suite_location / 'exclude.txt', exclude_file)
        else:
            with open(include_file, 'w'):
                pass
            with open(exclude_file, 'w'):
                pass

        if len(options) > 0:
            x = randrange(len(options))
            o = options[x]

            problem = o[0]
            option  = o[1]

            include = False
            coverage_to_time_ratio = None
            if not Path(suite_location).exists():
                # Use the first problem as initial suite.
                # Call to cache methods.
                Coverage(jacop_dist_location).get_covered_methods(option)
                shutil.copytree(option.parent, suite_location)
                with open(include_file, 'w'):
                    pass
                with open(exclude_file, 'w'):
                    pass
                included.add(problem)
                include = True
            else:
                # Merge more problems into the existing suite.
                if candi_location.exists():
                    shutil.rmtree(candi_location)
                    candi_location.mkdir()

                jacoco_merge(suite, option, candidate)
                cov_suite = Coverage(jacop_dist_location).get_covered_methods(suite)
                cov_candi = Coverage(jacop_dist_location).get_covered_methods(candidate)
                print("Suite", len(cov_suite))
                print("Candi", len(cov_candi))
                cov_total = cov_suite.union(cov_candi)
                cov_addition = cov_candi - cov_suite
                coverage_to_time_ratio = len(cov_addition) / 5
                if coverage_to_time_ratio > coverage_to_time_threshold:
                    print("Update suite with", len(cov_addition), "new methods from", problem)
                    shutil.rmtree(suite_location)
                    shutil.copytree(candi_location, suite_location)
                    include = True
                    included.add(problem)
                else:
                    shutil.rmtree(candi_location)
                    excluded.add(problem)

            file = include_file if include else exclude_file
            print(file.name[:-4].upper(), "(", "Ratio", str(coverage_to_time_ratio), ")", problem)
            with open(file, 'a') as f:
                f.write(problem + os.linesep)

            # Update suite
            if suite_initial_location.exists():
                shutil.rmtree(suite_initial_location)
            shutil.copytree(suite_location, suite_initial_location)
            shutil.copy2(include_file, suite_initial_location / 'include.txt')
            shutil.copy2(exclude_file, suite_initial_location / 'exclude.txt')

class Report:
    def __init__(self, data_location):
        self._data_location = data_location

        self._files   = set() # {(.html, .java.html)}
        self._methods = set()  # {name:string}
        self._classes = dict() # CLASSNAME => {label:string}

    def text_digest(text):
        return hashlib.md5(bytes(str(text), encoding = 'utf-8')).hexdigest()

    def _method_coverage_file(self):
        return self._data_location / 'method-coverage.txt'

    def _line_coverage_file(self, unit_name, unit_type):
        digest = Report.text_digest(unit_name)
        return self._data_location / (unit_type + '-' + digest + '.txt')

    def cover_method(self, method):
        with open(self._method_coverage_file(), 'a') as f:
            f.write(method + os.linesep)

    def cover_line(self, clazz, method, label):
        with open(self._line_coverage_file(clazz, 'CLC'), 'a') as f:
            f.write(label + os.linesep)
        if not method is None:
            with open(self._line_coverage_file(method, 'MLC'), 'a') as f:
                f.write(label + os.linesep)

    def load_packages(report_location):
        packages = []
        for root, folders, files in os.walk(report_location):
            for folder in folders:
                if not folder.startswith('jacoco-'):
                    packages.append(folder)
            break
        return packages

    def load_html_files(report, report_location, packages):
        fs = []
        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    skip_files = {
                        "index.html",
                        "index.source.html"
                    }
                    if not file in skip_files and not file.endswith('.java.html'):
                        fs.append((package, Path(root) / file))
                    else:
                        if not file.endswith('.java.html') and not file in skip_files:
                            print("Skip file", package, file)
                break

        for pkg, file in fs:
            #print("Parsing html", str(file))
            tree = ET.parse(file)
            root = tree.getroot()
            xmlns = lambda sym: "{http://www.w3.org/1999/xhtml}" + sym
            for tr in root.find(xmlns('body')).find(xmlns('table')).find(xmlns('tbody')).findall(xmlns('tr')):
                tds        = tr.findall(xmlns('td'))
                a_name     = tds[0].find(xmlns('a'))    # Used when .java.html exists (if source was available).
                s_name     = tds[0].find(xmlns('span')) # Used when source was not available during report generation.
                method     = (a_name if not a_name is None else s_name).text
                i_coverage = tds[2].text
                b_coverage = tds[4].text
                hit        = int(tds[-2].text) == 0 # 0 := hit; 1 := miss

                if hit:
                    report.cover_method(pkg + "." + method)

    def load_java_files(report, report_location, packages):
        fs = []
        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    if file.endswith('.java.html'):
                        fs.append((package, Path(root) / file))
                break

        p  = re.compile('^<span class="fc" id="L(\\d+)"')
        p2 = re.compile('^\\s*\\}</span>')
        p3 = re.compile('(\\w+)\\(([^\\)]*)\\)\\s*\\{')
        # p4 = re.compile('^\\s*\\{')

        for pkg, file in fs:
            with open(file, 'r') as f:
                method = None
                for i, line in enumerate(f):
                    method_match = p3.findall(line)
                    if len(method_match) > 0:
                        name, params = method_match[-1]
                        params = params.strip()
                        signature = parse_plist.get_signature(params)

                        TODO

                        parts = [x.strip().split(" ")[0].strip() for x in params.split(",")]
                        method = "{}({})".format(name, ", ".join(parts))
                        # TODO: Does not work with generics yet...
                        print("Enter Method", method)
                    # Only include full line statement coverage.
                    # We are only interested in blocks, branching
                    # is implied.
                    # <span class="fc" id="L70">
                    #
                    # Exclude:
                    # <span class="fc bfc" id="L153" title="All 2 branches covered.">
                    # <span class="pc bpc" id="L156" title="1 of 2 branches missed.">
                    # <span class="nc" id="L157">
                    # <span class="nc" id="L84">    }</span>
                    # ...
                    m = p.match(line)
                    if not m is None:
                        next = m.span()[1]
                        id   = m.groups()[0]
                        rest = m.groups()[0][next:]
                        if not p2.match(rest):
                            report.cover_line(file.name, method, id)

    def load(report_location, data_location):
        report           = Report(data_location)
        packages         = Report.load_packages(report_location)
        Report.load_html_files(report, report_location, packages)
        Report.load_java_files(report, report_location, packages)
        return report

class TestCoverage:
    def __init__(self):
        pass

class CoverageStore:
    def __init__(self, location):
        self._location = location

    def store_report(self, test, report_location):
        name   = Report.text_digest(test)          # TODO: Store name list mapping to digest.
        data   = self._location / name
        data.mkdir(parents = True)
        report = Report.load(report_location, data)

    def find_report(self, test):
        data = self._location / Report.text_digest(test)
        return Report(data) if data.exists() else None

    def _write_unit_coverage(self, units, tests, unit_type):
        for ui, unit in enumerate(sorted(units)):
            ml = dict() # {line => {test}}
            mt = dict() # {test => {line}}
            mc = set()  # Tests covering 'ui'.
            for ti, test in enumerate(sorted(tests)):
                file = self._location / test / (unit_type + '-' + unit + '.txt')
                if Path(file).exists():
                    mc.add(ti)
                    with open(file, 'r') as f:
                        for line in f:
                            li = int(line)
                            if not li in ml:
                                ml[li] = set()
                            if not ti in mt:
                                mt[ti] = set()
                            ml[li].add(ti)
                            mt[ti].add(li)

            for ti, test in enumerate(sorted(tests)):
                # What is the coverage per unit time for 'ti'?
                # How many lines does 'ti' cover of the total available in 'ui'?, an in what time?
                ui_lc = len(ml)     # Number of lines in 'ui'.
                ti_ml = len(mt[ti]) # Number of lines covered by 'ti' in 'ui'.
                xt    = 500         # Test execution time. (Record and write to file in store.) (TODO)
                score = 0
                n = len(mc)          # Tests covering 'ui'.
                for li in mt[ti]:    # Lines covered by 'ti'.
                    lc = len(ml[li]) # Total number of tests covering 'li'.
                    score = score + (n - lc)*(n - lc)
                rarity = sqrt(score) / (n-1)
                base_score  = (ti_ml / ui_lc) / xt # Coverage per unit time.
                final_score = base_score + rarity  #
                # '<unit_type>.vec' holds "coverage per unit time" for 'ti' on units 'ui'.
                with open(self._location / test / (unit_type + '.vec'), 'a') as f:
                    f.write(str(final_score) + os.linesep) # Write element: m['ti','ui'] = final_score;

    def summarize(self):
        test_folders = []
        for root, folders, files in os.walk(self._location):
            test_folders.extend(folders)
            break

        tests   = set()
        classes = set()
        methods = set()

        MLC = 'MLC' # Method Line Coverage
        CLC = 'CLC' # Class  Line Coverage

        for test in test_folders:
            tests.add(test)
            for root, folders, files in os.walk(test):
                for file in files:
                    if file.startswith(MLC + '-'):
                        stem   = Path(file).stem
                        method = stem[stem.rfind('-')+1:]
                        methods.add(method)
                    if file.startswith(CLC + '-'):
                        stem  = Path(file).stem
                        clazz = stem[stem.rfind('-')+1:]
                        classes.add(clazz)
                break

        # TODO: We only have class lines at the moment...
        #       Need to find start line number of method declarations
        #       - Can get from refactoring framework by loading in code and parsing files..., or
        #       - Use python regex...

        self._write_unit_coverage(tests, methods, MLC)
        self._write_unit_coverage(tests, classes, CLC)

        # Write line-index-mappings for tests, classes, and methods.

        with open(self._location / 'tests.index', 'w') as f:
            for test in sorted(tests):
                f.write(str(test) + os.linesep)

        with open(self._location / 'classes.index', 'w') as f:
            for clazz in sorted(classes):
                f.write(clazz + os.linesep)

        # TODO: Need to map line numbers to methods.
        #
        with open(self._location / 'methods.index', 'w') as f:
            for method in sorted(methods):
                f.write(method + os.linesep)

        # TODO: Save digest-to-name mappings.

        
class Coverage:

    # I'm guessing the jacoco report html classes in
    # '.java.html' files have the following meaning
    # (only needed if we decide to look at line
    # coverage):
    # fc := full coverage
    # pc := partial coverage
    # nc := no coverage
    # bpc := branch - partial coverage
    # bfc := branch - full coverage
    
    def __init__(self, dist_location):
        self.dist_location = Path(dist_location)

    def _find_covered_methods(self, report_location):
        methods          = set()
        packages         = []
        class_html_files = []

        for root, folders, files in os.walk(report_location):
            for folder in folders:
                if not folder.startswith('jacoco-'):
                    packages.append(folder)
            break

        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    skip_files = {
                        "index.html",
                        "index.source.html"
                    }
                    if not file in skip_files and not file.endswith('.java.html'):
                        class_html_files.append((package, Path(root) / file))
                    else:
                        if not file.endswith('.java.html') and not file in skip_files:
                            print("Skip file", package, file)
                break

        for pkg, file in class_html_files:
            #print("Parsing html", str(file))
            tree = ET.parse(file)
            root = tree.getroot()
            xmlns = lambda sym: "{http://www.w3.org/1999/xhtml}" + sym
            for tr in root.find(xmlns('body')).find(xmlns('table')).find(xmlns('tbody')).findall(xmlns('tr')):
                tds        = tr.findall(xmlns('td'))
                a_name     = tds[0].find(xmlns('a'))    # Used when .java.html exists (if source was available).
                s_name     = tds[0].find(xmlns('span')) # Used when source was not available during report generation.
                method     = (a_name if not a_name is None else s_name).text
                #i_coverage = tds[2].text
                #b_coverage = tds[4].text
                hit        = int(tds[-2].text) == 0 # 0 := hit; 1 := miss

                if hit:
                    #print("Method", method, "IC", i_coverage, "BC", b_coverage)
                    methods.add(pkg + "." + method)

        print("Found", str(len(methods)), "methods in", str(report_location))
        return methods

    def get_covered_methods(self, exec_filepath):
        path    = Path(exec_filepath)
        methods = set()
        methods_file = path.parent / 'methods.txt'
        if methods_file.exists():
            print("Loading methods file", str(methods_file))
            with open(methods_file, 'r') as f:
                for line in f:
                    methods.add(line)
        else:
            with tempfile.TemporaryDirectory() as location:
                output_location = Path(location)
                jacoco_report(exec_filepath, output_location, self.dist_location)
                methods = self._find_covered_methods(output_location / 'report')
            print("Writing methods file", str(methods_file))
            with open(methods_file, 'w') as f:
                for m in sorted(methods):
                    f.write(m + os.linesep)
        return methods

if __name__ == '__main__':
    main()
    #find_sub_suite('reports', 'jacop-4.10.0')


    # https://www.jacoco.org/jacoco/trunk/doc/cli.html
    #java -jar jacococli.jar merge [<execfiles> ...] --destfile <path> [--help] [--quiet]

    # 
    #java -jar jacococli.jar execinfo [<execfiles> ...] [--help] [--quiet]
    #
    # Excerpt:
    #
    # CLASS ID,        HITS/PROBES, CLASS NAME
    # e4edab7507c7b45b   17 of  30  org/jacop/core/Var
    #
