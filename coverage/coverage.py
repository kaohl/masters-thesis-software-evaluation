#!/bin/env python

import argparse
import hashlib
import math
import os
from pathlib import Path
from random import randrange
import re
import shutil
import subprocess
import tempfile
import xml.etree.ElementTree as ET

import parse_plist

# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.zip
# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.tar.gz

agent_jar = "tools/jacoco-0.8.12/lib/jacocoagent.jar"
cli_jar   = "tools/jacoco-0.8.12/lib/jacococli.jar"
junit_jar = "tools/junit-5/junit-platform-console-standalone-1.11.4.jar"

def get_problems(location):
    problems = []
    for root, folders, files in os.walk(location):
        for file in files:
            if file.endswith('.fzn'):
                path = Path(root) / Path(file).stem
                test = Path(os.path.sep.join(path.parts[-3:]))
                print("Test", test)
                problems.append(test)
    return problems

def get_random_selection(n, problems):
    selection = []
    for i in range(n):
        selection.append(problems[randrange(len(problems))])
    return selection

def generate_coverage_report(problem, jacop_root, report_storage, store):
    # See: src/test/fz/listchoosegenerator.sh
    # Generates problems into a 'mizincbasedchosen/list.txt'.
    # We don't use this script, but instead generate tests
    # into the list by our own method, but execute them as
    # if generated by that script.
    problem_list     = jacop_root / 'src/test/fz/mizincbasedchosen/list.txt'
    problem_list_bak = problem_list.parent / 'list.txt.bak'

    # Save distributed defaults.
    if Path(problem_list).exists() and not Path(problem_list_bak).exists():
        shutil.copy2(problem_list, problem_list_bak)

    # Write single problem to list.
    with open(problem_list, 'w') as f:
        f.write(str(problem) + os.linesep)

    # Run tests with jacocoagent to get 'jacoco.exec'.

    destfile = "jacoco.exec"
    output   = "report"

    jacoco_options = [
        "output=file",
        "destfile=" + destfile
    ]
    target_classes      = 'target/classes'
    target_test_classes = 'target/test-classes'
    junit_options = [
        "--class-path",
        ":".join([target_classes, target_test_classes]),
        "--select-class",
        "org.jacop.MizincBasedChosen"
    ]
    cmd = " ".join([
        "java",
        "-javaagent:" + agent_jar + "=" + ",".join(jacoco_options),
        "-jar",
        junit_jar,
    ] + junit_options)
    result = subprocess.run(
        cmd,
        shell = True,
        cwd = str(jacop_root),
        stdout = subprocess.PIPE,
        stderr = subprocess.STDOUT
    )
    p = re.compile('(\\d+) ms')
    text = result.stdout.decode('utf-8')
    junit_reported_execution_time = p.findall(text)[0]
    print("--- SUBPROCESS OUTPUT ---")
    print(text)
    print("--- SUBPROCESS OUTPUT END ---")
    print("CAPTURED EXECUTION TIME", junit_reported_execution_time, "ms")

    # Generate report using jacococli.

    cmd_jacoco_cli = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        destfile,
        "--html",
        output,
        "--sourcefiles",
        "src/main/java",
        "--classfiles",
        target_classes
    ])
    subprocess.run(cmd_jacoco_cli, shell = True, cwd = str(jacop_root))
    
    store_at = report_storage / problem
    print("Store report", store_at)
    store_at.mkdir(parents = True)

    # TODO: Extract info from report and don't save report. (Only need execfile and methods.)
    
    shutil.copytree(jacop_root / 'report', store_at / 'report')
    shutil.copy2(jacop_root / 'jacoco.exec', store_at / 'jacoco.exec')

    # Extract and store coverage information.
    store.store_report(problem, junit_reported_execution_time, store_at / 'report')
    store.summarize()

def main():

    # NOTE
    # Prior to running this script,
    # make sure to run 'mvn compile'
    # and 'mvn test-compile' in
    # targeted jacop distribution.

    store          = CoverageStore(Path('coverage_store'))
    report_storage = 'reports'
    accept_test_p  = lambda p: not (Path(report_storage) / p).exists()

    dist      = Path('jacop-4.10.0')
    category  = 'upTo5sec'
    location  = 'src/test/fz/' + category
    problems  = get_problems(dist / location)

    if not (dist / 'tools').exists():
        shutil.copytree('tools', dist / 'tools')

    # Select tests at random in the beginning
    # to try to avoid bias in case we don't
    # have time to run all. However, when we
    # can't find a test to run after N random
    # selections, do a linear search starting
    # from a random index.

    n = 1
    while n > 0:
        found = False
        # Try run one at random.
        for i in range(10):
            problem = get_random_selection(1, problems)[0]
            if accept_test_p(problem):
                print("Select problem", problem)
                generate_coverage_report(problem, dist, report_storage, store)
                found = True
                break
        if not found:
            # Split sequence at random point.
            x = randrange(len(problems))
            print("Defaulting to sequential search starting at index", str(x))
            # Search first half.
            for i in range(x):
                problem = problems[i]
                if accept_test_p(problem):
                    print("Select problem", problem)
                    generate_coverage_report(problem, dist, report_storage, store)
                    found = True
                    break
            if not found:
                # Search second half.
                for i in range(x, len(problems)):
                    problem = problems[i]
                    if accept_test_p(problem):
                        print("Select problem", problem)
                        generate_coverage_report(problem, dist, report_storage, store)
                        found = True
                        break
        if not found:
            print("Coverage is complete.")
            break
        n = n - 1

def jacoco_report(exec_file, output_location, jacop_dist_location):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        str(exec_file),
        "--html",
        str(output_location / 'report'),
        "--sourcefiles",
        str(jacop_dist_location / "src/main/java"),
        "--classfiles",
        str(jacop_dist_location / "target/classes")
    ])
    subprocess.run(cmd, shell = True)

def jacoco_merge(src_1, src_2, dst):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "merge",
        str(src_1),
        str(src_2),
        "--destfile",
        str(dst)
    ])
    subprocess.run(cmd, shell = True)

def find_sub_suite(storage, jacop_dist_location):

    # Trade-off between time and coverage.
    # Only include a test if it gives a significant
    # coverage boost as defined by this threshold.
    #
    # TODO: Needs calibration.
    #
    coverage_to_time_threshold = 1

    # Files already merged into suite.
    included = set()
    excluded = set()
    suite_initial_location = Path('suite')
    suite_initial_include_file = suite_initial_location / 'include.txt'
    suite_initial_exclude_file = suite_initial_location / 'exclude.txt'
    if suite_initial_location.exists():
        with open(suite_initial_include_file, 'r') as f:
            for line in f:
                print("Init included", line)
                included.add(line.strip())
        with open(suite_initial_exclude_file, 'r') as f:
            for line in f:
                print("Init excluded", line)
                excluded.add(line.strip())

    #print("Initial included", included)
    #print("Initial excluded", excluded)

    options = []
    for root, folders, files in os.walk(storage):
        for file in files:
            if file == 'jacoco.exec':
                problem = os.path.sep.join(Path(root).parts[-3:])
                path    = Path(root) / file
                print("Test problem", problem)
                if not (problem in included or problem in excluded):
                    options.append((problem, path))

    with tempfile.TemporaryDirectory() as temp:
        suite_location = Path(temp) / 'suite'
        candi_location = Path(temp) / 'candi'

        suite     = suite_location / 'jacoco.exec'
        candidate = candi_location / 'jacoco.exec'

        include_file = Path(temp) / 'include.txt'
        exclude_file = Path(temp) / 'exclude.txt'

        if suite_initial_location.exists():
            shutil.copytree(suite_initial_location, suite_location)
            shutil.copy2(suite_location / 'include.txt', include_file)
            shutil.copy2(suite_location / 'exclude.txt', exclude_file)
        else:
            with open(include_file, 'w'):
                pass
            with open(exclude_file, 'w'):
                pass

        if len(options) > 0:
            x = randrange(len(options))
            o = options[x]

            problem = o[0]
            option  = o[1]

            include = False
            coverage_to_time_ratio = None
            if not Path(suite_location).exists():
                # Use the first problem as initial suite.
                # Call to cache methods.
                Coverage(jacop_dist_location).get_covered_methods(option)
                shutil.copytree(option.parent, suite_location)
                with open(include_file, 'w'):
                    pass
                with open(exclude_file, 'w'):
                    pass
                included.add(problem)
                include = True
            else:
                # Merge more problems into the existing suite.
                if candi_location.exists():
                    shutil.rmtree(candi_location)
                    candi_location.mkdir()

                jacoco_merge(suite, option, candidate)
                cov_suite = Coverage(jacop_dist_location).get_covered_methods(suite)
                cov_candi = Coverage(jacop_dist_location).get_covered_methods(candidate)
                print("Suite", len(cov_suite))
                print("Candi", len(cov_candi))
                cov_total = cov_suite.union(cov_candi)
                cov_addition = cov_candi - cov_suite
                coverage_to_time_ratio = len(cov_addition) / 5
                if coverage_to_time_ratio > coverage_to_time_threshold:
                    print("Update suite with", len(cov_addition), "new methods from", problem)
                    shutil.rmtree(suite_location)
                    shutil.copytree(candi_location, suite_location)
                    include = True
                    included.add(problem)
                else:
                    shutil.rmtree(candi_location)
                    excluded.add(problem)

            file = include_file if include else exclude_file
            print(file.name[:-4].upper(), "(", "Ratio", str(coverage_to_time_ratio), ")", problem)
            with open(file, 'a') as f:
                f.write(problem + os.linesep)

            # Update suite
            if suite_initial_location.exists():
                shutil.rmtree(suite_initial_location)
            shutil.copytree(suite_location, suite_initial_location)
            shutil.copy2(include_file, suite_initial_location / 'include.txt')
            shutil.copy2(exclude_file, suite_initial_location / 'exclude.txt')

class Report:
    def __init__(self, data_location):
        self._data_location = data_location

        self._files   = set() # {(.html, .java.html)}
        self._methods = set()  # {name:string}
        self._classes = dict() # CLASSNAME => {label:string}

    def text_digest(text):
        return hashlib.md5(bytes(str(text), encoding = 'utf-8')).hexdigest()

    def _method_coverage_file(self):
        return self._data_location / 'method-coverage.txt'

    def _execution_time_file(self):
        return self._data_location / 'execution_time.txt'

    def _line_coverage_file(self, unit_name, unit_type):
        digest = Report.text_digest(unit_name)
        return self._data_location / (unit_type + '-' + digest + '.txt')

    def write_execution_time(self, xtime):
        with open(self._execution_time_file(), 'w') as f:
            f.write(str(xtime) + os.linesep)

    def execution_time(self):
        with open(self._execution_time_file(), 'r') as f:
            return int(f.readlines()[0].strip())

    def cover_method(self, method):
        with open(self._method_coverage_file(), 'a') as f:
            f.write(method + os.linesep)

    def cover_line(self, clazz, method, label):
        clc = self._line_coverage_file(clazz, 'CLC')
        mlc = self._line_coverage_file(method, 'MLC')
        print("CLC", label, clazz, clc)
        print("MLC", label, method, mlc)
        with open(clc, 'a') as f:
            f.write(label + os.linesep)
        if not method is None:
            with open(mlc, 'a') as f:
                f.write(label + os.linesep)

    def load_packages(report_location):
        packages = []
        for root, folders, files in os.walk(report_location):
            for folder in folders:
                if not folder.startswith('jacoco-'):
                    packages.append(folder)
            break
        return packages

    def load_html_files(report, report_location, packages):
        fs = []
        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    skip_files = {
                        "index.html",
                        "index.source.html"
                    }
                    if not file in skip_files and not file.endswith('.java.html'):
                        fs.append((package, Path(root) / file))
                    else:
                        if not file.endswith('.java.html') and not file in skip_files:
                            print("Skip file", package, file)
                break

        for pkg, file in fs:
            #print("Parsing html", str(file))
            tree = ET.parse(file)
            root = tree.getroot()
            xmlns = lambda sym: "{http://www.w3.org/1999/xhtml}" + sym
            for tr in root.find(xmlns('body')).find(xmlns('table')).find(xmlns('tbody')).findall(xmlns('tr')):
                tds        = tr.findall(xmlns('td'))
                a_name     = tds[0].find(xmlns('a'))    # Used when .java.html exists (if source was available).
                s_name     = tds[0].find(xmlns('span')) # Used when source was not available during report generation.
                method     = (a_name if not a_name is None else s_name).text
                i_coverage = tds[2].text
                b_coverage = tds[4].text
                hit        = int(tds[-2].text) == 0 # 0 := hit; 1 := miss

                if hit:
                    report.cover_method(pkg + "." + method)

    def load_java_files(report, report_location, packages):
        fs = []
        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    if file.endswith('.java.html'):
                        path  = Path(root) / file
                        clazz = file[:file.find('.')]
                        fs.append((package, clazz, path))
                break

        ppkg = re.compile('\\s*package\\s+([^;]+);')
        p  = re.compile('^<span class="fc" id="L(\\d+)"')
        p2 = re.compile('^\\s*\\}</span>')
        p3 = re.compile('(\\w+)\\(([^\\)]*)\\)\\s*\\{')
        # p4 = re.compile('^\\s*\\{') # TODO: Consider skipping coverage on closing braces to reduce labels.

        # ATTENTION: (TODO)
        # The line to method association does not work for nested types.
        # The issue is that we don't know when we are leaving a class even
        # if we know where it starts based on the 'class' keyword.
        #  Alt. Solution 1: Work with indentation of 'class' line and closing brace lines.
        #  Alt. Solution 2: Count open/closed braces as we parse line-by-line and look for 'class'.
        #
        # *** Anonymous classes are more problematic.
        #     - Perhaps we could exclude lines within methods declarations
        #       that have a too large indentation and simply add those lines
        #       to the wrapping type but not to the last seen method:
        #       class A {
        #            class B {
        #                void f() {
        #                    new X() {
        #                        <record coverage here for outer method: <pkg>.A.B.f()>.
        #                    };
        #     - If we trace the context on a stack as we parse class declarations
        #       we can always commit the line to the inner most method whose parent
        #       context is a class. This would be <pkg>.A.B.f() in this example.
        #
        # *** Note that the .html file gives us plain line coverage
        #     even when the .java.html file is not available.

        java_keywords = { 'if', 'switch', 'for', 'while' }
        for package_name, clazz_name, file in fs:
            with open(file, 'r') as f:
                #package_name = None
                method_name = None
                method      = None
                for i, line in enumerate(f):
                    # NOTE: Already have package name from folder name.
                    #package_match = ppkg.match(line)
                    #if not package_match is None:
                    #    package_name = package_match.groups()[0]
                    #    pass
                    method_match = p3.findall(line)
                    if len(method_match) > 0:
                        method_name, params = method_match[-1]
                        if method_name in java_keywords:
                            continue
                        signature = parse_plist.get_signature(params)
                        method = "{}.{}.{}({})".format(package_name,clazz_name, method_name, signature)
                        print("Enter Method", method)
                    # Only include full line statement coverage.
                    # We are only interested in blocks, branching
                    # is implied.
                    # <span class="fc" id="L70">
                    #
                    # Exclude:
                    # <span class="fc bfc" id="L153" title="All 2 branches covered.">
                    # <span class="pc bpc" id="L156" title="1 of 2 branches missed.">
                    # <span class="nc" id="L157">
                    # <span class="nc" id="L84">    }</span>
                    # ...
                    m = p.match(line)
                    if not m is None:
                        next = m.span()[1]
                        id   = m.groups()[0]
                        rest = m.groups()[0][next:]
                        if not p2.match(rest):
                            qualified_class_name = package_name + '.' + clazz_name
                            report.cover_line(qualified_class_name, method, id)

    def load(report_location, data_location):
        report           = Report(data_location)
        packages         = Report.load_packages(report_location)
        Report.load_html_files(report, report_location, packages)
        Report.load_java_files(report, report_location, packages)
        return report

class TestCoverage:
    def __init__(self):
        pass

class CoverageStore:
    def __init__(self, location):
        self._location = location

    def store_report(self, test, xtime, report_location):
        name   = Report.text_digest(test)
        data   = self._location / name
        data.mkdir(parents = True)
        report = Report.load(report_location, data)
        report.write_execution_time(xtime)

    def find_report_by_name(self, test_name):
        data = self._location / Report.text_digest(test_name)
        return Report(data) if data.exists() else None

    def find_report_by_digest(self, test):
        data = self._location / test
        return Report(data) if data.exists() else None

    def execution_time(self, test):
        return self.find_report_by_digest(test).execution_time()

    def _write_unit_coverage(self, tests, units, unit_type):
        print("Resetting test coverage vectors")
        for test in tests:
            with open(self._location / test / (unit_type + '.vec'), 'w'):
                pass
        print("Computing test coverage vectors", unit_type)
        n_file_contribs = 0
        n_line_contribs = 0
        for ui, unit in enumerate(sorted(units)):
            ml = dict() # {line => {test}}
            mt = dict() # {test => {line}}
            mc = set()  # Tests covering 'ui'.
            for ti, test in enumerate(sorted(tests)):
                file = self._location / test / (unit_type + '-' + unit + '.txt')
                if Path(file).exists():
                    n_file_contribs = n_file_contribs + 1
                    mc.add(ti)
                    with open(file, 'r') as f:
                        for line in f:
                            li = int(line)
                            if not li in ml:
                                ml[li] = set()
                            if not ti in mt:
                                mt[ti] = set()
                            ml[li].add(ti)
                            mt[ti].add(li)
                            n_line_contribs = n_line_contribs + 1
                else:
                    # The current test does not cover the current unit.
                    # raise ValueError("No file", test, unit, file)
                    pass

            ui_lc = len(ml) # Number of lines in 'ui'.
            ui_tc = len(mc) # Tests covering 'ui'.
            print("File contribs", str(n_file_contribs))
            print("Line contribs", str(n_line_contribs))
            print("Computing coverage on unit", unit)
            for ti, test in enumerate(sorted(tests)):
                ti_lc = len(mt.get(ti, set()))    # Lines covered by 'ti' in 'ui'.
                xt    = self.execution_time(test) #
                lcput = (ti_lc / ui_lc) / xt      # Line coverage per unit time.

                score    = 0                 # Bias towards edge cases (rarity).
                ti_lines = mt.get(ti, set()) # Lines in 'ui' covered by 'ti'.
                for li in ti_lines:
                    li_tc      = len(ml[li])   # Total number of tests covering 'li'.
                    uniqueness = ui_tc - li_tc # Number of tests covering 'ui' but not 'li', which is covered by 'ti'.
                    score      = score + uniqueness * uniqueness
                    # Note: The bias will be zero if all tests cover a line.
                rarity      = math.sqrt(score / (len(ti_lines) or 1)) # Standard deviation.
                final_score = lcput + rarity

                # '<unit_type>.vec' holds "coverage per unit time" for 'ti' on units 'ui'.
                with open(self._location / test / (unit_type + '.vec'), 'a') as f:
                    f.write(str(final_score) + os.linesep) # Write element: m['ti','ui'] = final_score;

    # Return tests in sorted order.
    def get_all_tests(self):
        test_folders = []
        for root, folders, files in os.walk(self._location):
            test_folders.extend(folders)
            break
        # Explicit sort to avoid depending on sorting returned by walk.
        return [ t for t in sorted(test_folders) ]

    def summarize(self):
        test_folders = self.get_all_tests()

        tests   = set() # Total set of tests.
        classes = set() # Total set of classes for which coverage has been found.
        methods = set() # Total set of methods for which coverage has been found.

        MLC = 'MLC' # Method Line Coverage
        CLC = 'CLC' # Class  Line Coverage

        for test in test_folders:
            tests.add(test)
            for root, folders, files in os.walk(self._location / test):
                for file in files:
                    if file.startswith(MLC + '-'):
                        method = Path(file).stem[4:]
                        methods.add(method)
                        #if not Path(self._location / test / ('MLC-' + method + '.txt')).exists():
                        #    raise ValueError()

                    if file.startswith(CLC + '-'):
                        clazz = Path(file).stem[4:]
                        classes.add(clazz)
                        #if not Path(self._location / test / ('CLC-' + clazz + '.txt')).exists():
                        #    raise ValueError()
                break

        print("Processing")
        print(  "tests  ", len(tests))
        print(  "classes", len(classes))
        print(  "methods", len(methods))

        # NOTE
        # We should be able to get more exact line numbers for
        # method start and end using the code parser in the
        # refactoring framework, if we need it.
        #
        # We are using line coverage to try to determine if the
        # line coverage provided by a particular test is more
        # valuable (rare) than for other tests that cover the
        # same method.
        #
        # This will bias the test selection towards edge cases.
        # So we might want to be able to run the algorithm with
        # this enabled and then also disabled and then
        # potentially join the results.

        self._write_unit_coverage(tests, classes, CLC)
        self._write_unit_coverage(tests, methods, MLC)

        # Write line-index-mappings for tests, classes, and methods.

        with open(self._location / 'tests.index', 'w') as f:
            for test in sorted(tests):
                f.write(str(test) + os.linesep)

        with open(self._location / 'classes.index', 'w') as f:
            for clazz in sorted(classes):
                f.write(clazz + os.linesep)

        # TODO: Need to map line numbers to methods.
        #
        with open(self._location / 'methods.index', 'w') as f:
            for method in sorted(methods):
                f.write(method + os.linesep)

        # TODO: Save digest-to-name mappings.

    # Return all tests that cover one or more of
    # specified fully qualified method names.
    def find_tests_covering_methods(self, methods):
        digests   = set([ Report.text_digest(method) for method in methods ])
        tests     = set(self.get_all_tests())
        selection = set()
        for test in tests:
            for digest in digests:
                if (self._location / test / ('MLC-' + digest + '.txt')).exists():
                    selection.add(test)
        return selection

    def generate_method_vector(self, dzn_file): # TODO: Constrain tests to include by user input.
        tests     = self.get_all_tests()
        mlc_lines = [] # Unit coverage vector per test.
        tn        = len(tests)
        un        = None
        txms      = []
        with open(dzn_file, 'w') as dzn:
            first = True
            for test in tests:
                txms.append(str(self.execution_time(test)))
                elems = None
                with open(self._location / test / 'MLC.vec', 'r') as f:
                    elems = [ x.strip() for x in f.readlines() ]
                if first:
                    un = len(elems)
                    dzn.write('Tn = ' + str(tn) + os.linesep)
                    dzn.write('Un = ' + str(un) + os.linesep)
                    dzn.write('uc = array2d(0..Tn-1, 0..Un-1, [|')
                dzn.write(','.join(elems) + '|')
                first = False
            dzn.write(']);' + os.linesep)
            dzn.write('txms = array1d(0..Tn-1, [' + ','.join(txms) + ']);' + os.linesep)

class Coverage:

    # I'm guessing the jacoco report html classes in
    # '.java.html' files have the following meaning
    # (only needed if we decide to look at line
    # coverage):
    # fc := full coverage
    # pc := partial coverage
    # nc := no coverage
    # bpc := branch - partial coverage
    # bfc := branch - full coverage
    
    def __init__(self, dist_location):
        self.dist_location = Path(dist_location)

    def _find_covered_methods(self, report_location):
        methods          = set()
        packages         = []
        class_html_files = []

        for root, folders, files in os.walk(report_location):
            for folder in folders:
                if not folder.startswith('jacoco-'):
                    packages.append(folder)
            break

        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    skip_files = {
                        "index.html",
                        "index.source.html"
                    }
                    if not file in skip_files and not file.endswith('.java.html'):
                        class_html_files.append((package, Path(root) / file))
                    else:
                        if not file.endswith('.java.html') and not file in skip_files:
                            print("Skip file", package, file)
                break

        for pkg, file in class_html_files:
            #print("Parsing html", str(file))
            tree = ET.parse(file)
            root = tree.getroot()
            xmlns = lambda sym: "{http://www.w3.org/1999/xhtml}" + sym
            for tr in root.find(xmlns('body')).find(xmlns('table')).find(xmlns('tbody')).findall(xmlns('tr')):
                tds        = tr.findall(xmlns('td'))
                a_name     = tds[0].find(xmlns('a'))    # Used when .java.html exists (if source was available).
                s_name     = tds[0].find(xmlns('span')) # Used when source was not available during report generation.
                method     = (a_name if not a_name is None else s_name).text
                #i_coverage = tds[2].text
                #b_coverage = tds[4].text
                hit        = int(tds[-2].text) == 0 # 0 := hit; 1 := miss

                if hit:
                    #print("Method", method, "IC", i_coverage, "BC", b_coverage)
                    methods.add(pkg + "." + method)

        print("Found", str(len(methods)), "methods in", str(report_location))
        return methods

    def get_covered_methods(self, exec_filepath):
        path    = Path(exec_filepath)
        methods = set()
        methods_file = path.parent / 'methods.txt'
        if methods_file.exists():
            print("Loading methods file", str(methods_file))
            with open(methods_file, 'r') as f:
                for line in f:
                    methods.add(line)
        else:
            with tempfile.TemporaryDirectory() as location:
                output_location = Path(location)
                jacoco_report(exec_filepath, output_location, self.dist_location)
                methods = self._find_covered_methods(output_location / 'report')
            print("Writing methods file", str(methods_file))
            with open(methods_file, 'w') as f:
                for m in sorted(methods):
                    f.write(m + os.linesep)
        return methods

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--collect', required = False, action = 'store_true',# default = False,
        help = "Run a random tests and collect coverage information.")
    parser.add_argument('-n', required = False, type = int, default = 1, help = "Number of tests to collect.")
    parser.add_argument('-s', '--find-method-coverage', required = False, action = 'store_true', default = False,
        help = "Find tests covering methods specified using the -m or --methods option.")
    parser.add_argument('-m', '--methods', required = False, nargs='+', default = [],
        help = "List of fully qualified method signatures. I.e., values on format '<pkg>.<method-name>(<parameter type list>)'.")
    parser.add_argument('--method-vec', required = False, action = 'store_true',
        help = "Generate method unit vector for minizinc program.")
    args = parser.parse_args()

    # TODO: Alternative approach. Not fully working. Issue when copying folders around.
    #find_sub_suite('reports', 'jacop-4.10.0')

    if args.collect:
        for i in range(max(1, args.n)):
            main()
    elif args.find_method_coverage:
        # Example (Note: Must be fully qualified method signatures.)
        # methods = [
        #     'org.jacop.constraints.regular.RegStateInt.RegStateInt(int,int,int,int)'
        # ]
        store = CoverageStore(Path('coverage_store'))
        for t in store.find_tests_covering_methods(args.methods):
            print(t)
    elif args.method_vec:
        store = CoverageStore(Path('coverage_store'))
        store.generate_method_vector(Path('mlc.dzn'))
    else:
        parser.print_help()

    # https://www.jacoco.org/jacoco/trunk/doc/cli.html
    #java -jar jacococli.jar merge [<execfiles> ...] --destfile <path> [--help] [--quiet]

    # 
    #java -jar jacococli.jar execinfo [<execfiles> ...] [--help] [--quiet]
    #
    # Excerpt:
    #
    # CLASS ID,        HITS/PROBES, CLASS NAME
    # e4edab7507c7b45b   17 of  30  org/jacop/core/Var
    #
