#!/bin/env python

import os
from pathlib import Path
from random import randrange
import shutil
import subprocess
import tempfile
import xml.etree.ElementTree as ET

# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.zip
# https://github.com/radsz/jacop/archive/refs/tags/4.10.0.tar.gz

agent_jar = "tools/jacoco-0.8.12/lib/jacocoagent.jar"
cli_jar   = "tools/jacoco-0.8.12/lib/jacococli.jar"
junit_jar = "tools/junit-5/junit-platform-console-standalone-1.11.4.jar"

def get_problems(location):
    problems = []
    for root, folders, files in os.walk(location):
        for file in files:
            if file.endswith('.fzn'):
                path = Path(root) / Path(file).stem
                test = Path(os.path.sep.join(path.parts[-3:]))
                print("Test", test)
                problems.append(test)
    return problems

def get_random_selection(n, problems):
    selection = []
    for i in range(n):
        selection.append(problems[randrange(len(problems))])
    return selection

def generate_coverage_report(problem, jacop_root, report_storage):
    # See: src/test/fz/listchoosegenerator.sh
    # Generates problems into a 'mizincbasedchosen/list.txt'.
    # We don't use this script, but instead generate tests
    # into the list by our own method, but execute them as
    # if generated by that script.
    problem_list     = jacop_root / 'src/test/fz/mizincbasedchosen/list.txt'
    problem_list_bak = problem_list.parent / 'list.txt.bak'

    # Save distributed defaults.
    if Path(problem_list).exists() and not Path(problem_list_bak).exists():
        shutil.copy2(problem_list, problem_list_bak)

    # Write single problem to list.
    with open(problem_list, 'w') as f:
        f.write(str(problem) + os.linesep)

    # Run tests with jacocoagent to get 'jacoco.exec'.

    destfile = "jacoco.exec"
    output   = "report"

    jacoco_options = [
        "output=file",
        "destfile=" + destfile
    ]
    target_classes      = 'target/classes'
    target_test_classes = 'target/test-classes'
    junit_options = [
        "--class-path",
        ":".join([target_classes, target_test_classes]),
        "--select-class",
        "org.jacop.MizincBasedChosen"
    ]
    cmd = " ".join([
        "java",
        "-javaagent:" + agent_jar + "=" + ",".join(jacoco_options),
        "-jar",
        junit_jar,
    ] + junit_options)#  + " " + " ".join(junit_options)
    subprocess.run(cmd, shell = True, cwd = str(jacop_root))

    # Generate report using jacococli.

    cmd_jacoco_cli = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        destfile,
        "--html",
        output,
        "--sourcefiles",
        "src/main/java",
        "--classfiles",
        target_classes
    ])
    subprocess.run(cmd_jacoco_cli, shell = True, cwd = str(jacop_root))
    
    store_at = report_storage / problem
    print("Store report", store_at)
    store_at.mkdir(parents = True)

    # TODO: Extract info from report and don't save report. (Only need execfile and methods.)
    
    shutil.copytree(jacop_root / 'report', store_at / 'report')
    shutil.copy2(jacop_root / 'jacoco.exec', store_at / 'jacoco.exec')

def main():

    # NOTE
    # Prior to running this script,
    # make sure to run 'mvn compile'
    # and 'mvn test-compile' in
    # targeted jacop distribution.

    report_storage = 'reports'
    accept_test_p  = lambda p: not (Path(report_storage) / p).exists()

    dist      = Path('jacop-4.10.0')
    category  = 'upTo5sec'
    location  = 'src/test/fz/' + category
    problems  = get_problems(dist / location)

    if not (dist / 'tools').exists():
        shutil.copytree('tools', dist / 'tools')

    # Select tests at random in the beginning
    # to try to avoid bias in case we don't
    # have time to run all. However, when we
    # can't find a test to run after N random
    # selections, do a linear search starting
    # from a random index.

    n = 1
    while n > 0:
        found = False
        # Try run one at random.
        for i in range(10):
            problem = get_random_selection(1, problems)[0]
            if accept_test_p(problem):
                print("Select problem", problem)
                generate_coverage_report(problem, dist, report_storage)
                found = True
                break
        if not found:
            # Split sequence at random point.
            x = randrange(len(problems))
            print("Defaulting to sequential search starting at index", str(x))
            # Search first half.
            for i in range(x):
                problem = problems[i]
                if accept_test_p(problem):
                    print("Select problem", problem)
                    generate_coverage_report(problem, dist, report_storage)
                    found = True
                    break
            if not found:
                # Search second half.
                for i in range(x, len(problems)):
                    problem = problems[i]
                    if accept_test_p(problem):
                        print("Select problem", problem)
                        generate_coverage_report(problem, dist, report_storage)
                        found = True
                        break
        if not found:
            print("Coverage is complete.")
            break
        n = n - 1

def jacoco_report(exec_file, output_location, jacop_dist_location):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "report",
        str(exec_file),
        "--html",
        str(output_location / 'report'),
        "--sourcefiles",
        str(jacop_dist_location / "src/main/java"),
        "--classfiles",
        str(jacop_dist_location / "target/classes")
    ])
    subprocess.run(cmd, shell = True)

def jacoco_merge(src_1, src_2, dst):
    cmd = " ".join([
        "java",
        "-jar",
        cli_jar,
        "merge",
        str(src_1),
        str(src_2),
        "--destfile",
        str(dst)
    ])
    subprocess.run(cmd, shell = True)

def find_sub_suite(storage, jacop_dist_location):

    # Trade-off between time and coverage.
    # Only include a test if it gives a significant
    # coverage boost as defined by this threshold.
    #
    # TODO: Needs calibration.
    #
    coverage_to_time_threshold = 1

    # Files already merged into suite.
    included = set()
    excluded = set()
    suite_initial_location = Path('suite')
    suite_initial_include_file = suite_initial_location / 'include.txt'
    suite_initial_exclude_file = suite_initial_location / 'exclude.txt'
    if suite_initial_location.exists():
        with open(suite_initial_include_file, 'r') as f:
            for line in f:
                print("Init included", line)
                included.add(line.strip())
        with open(suite_initial_exclude_file, 'r') as f:
            for line in f:
                print("Init excluded", line)
                excluded.add(line.strip())

    #print("Initial included", included)
    #print("Initial excluded", excluded)

    options = []
    for root, folders, files in os.walk(storage):
        for file in files:
            if file == 'jacoco.exec':
                problem = os.path.sep.join(Path(root).parts[-3:])
                path    = Path(root) / file
                print("Test problem", problem)
                if not (problem in included or problem in excluded):
                    options.append((problem, path))

    with tempfile.TemporaryDirectory() as temp:
        suite_location = Path(temp) / 'suite'
        candi_location = Path(temp) / 'candi'

        suite     = suite_location / 'jacoco.exec'
        candidate = candi_location / 'jacoco.exec'

        include_file = Path(temp) / 'include.txt'
        exclude_file = Path(temp) / 'exclude.txt'

        if suite_initial_location.exists():
            shutil.copytree(suite_initial_location, suite_location)
            shutil.copy2(suite_location / 'include.txt', include_file)
            shutil.copy2(suite_location / 'exclude.txt', exclude_file)
        else:
            with open(include_file, 'w'):
                pass
            with open(exclude_file, 'w'):
                pass

        if len(options) > 0:
            x = randrange(len(options))
            o = options[x]

            problem = o[0]
            option  = o[1]

            include = False
            coverage_to_time_ratio = None
            if not Path(suite_location).exists():
                # Use the first problem as initial suite.
                # Call to cache methods.
                Coverage(jacop_dist_location).get_covered_methods(option)
                shutil.copytree(option.parent, suite_location)
                with open(include_file, 'w'):
                    pass
                with open(exclude_file, 'w'):
                    pass
                included.add(problem)
                include = True
            else:
                # Merge more problems into the existing suite.
                if candi_location.exists():
                    shutil.rmtree(candi_location)
                    candi_location.mkdir()

                jacoco_merge(suite, option, candidate)
                cov_suite = Coverage(jacop_dist_location).get_covered_methods(suite)
                cov_candi = Coverage(jacop_dist_location).get_covered_methods(candidate)
                print("Suite", len(cov_suite))
                print("Candi", len(cov_candi))
                cov_total = cov_suite.union(cov_candi)
                cov_addition = cov_candi - cov_suite
                coverage_to_time_ratio = len(cov_addition) / 5
                if coverage_to_time_ratio > coverage_to_time_threshold:
                    print("Update suite with", len(cov_addition), "new methods from", problem)
                    shutil.rmtree(suite_location)
                    shutil.copytree(candi_location, suite_location)
                    include = True
                    included.add(problem)
                else:
                    shutil.rmtree(candi_location)
                    excluded.add(problem)

            file = include_file if include else exclude_file
            print(file.name[:-4].upper(), "(", "Ratio", str(coverage_to_time_ratio), ")", problem)
            with open(file, 'a') as f:
                f.write(problem + os.linesep)

            # Update suite
            if suite_initial_location.exists():
                shutil.rmtree(suite_initial_location)
            shutil.copytree(suite_location, suite_initial_location)
            shutil.copy2(include_file, suite_initial_location / 'include.txt')
            shutil.copy2(exclude_file, suite_initial_location / 'exclude.txt')

class Coverage:

    # I'm guessing the jacoco report html classes in
    # '.java.html' files have the following meaning
    # (only needed if we decide to look at line
    # coverage):
    # fc := full coverage
    # pc := partial coverage
    # nc := no coverage
    # bpc := branch - partial coverage
    # bfc := branch - full coverage
    
    def __init__(self, dist_location):
        self.dist_location = Path(dist_location)
        
    def _find_covered_methods(self, report_location):
        methods          = set()
        packages         = []
        class_html_files = []

        for root, folders, files in os.walk(report_location):
            for folder in folders:
                if not folder.startswith('jacoco-'):
                    packages.append(folder)
            break

        for package in packages:
            package_location = report_location / package
            for root, folders, files in os.walk(package_location):
                for file in files:
                    skip_files = {
                        "index.html",
                        "index.source.html"
                    }
                    if not file in skip_files and not file.endswith('.java.html'):
                        class_html_files.append((package, Path(root) / file))
                    else:
                        if not file.endswith('.java.html') and not file in skip_files:
                            print("Skip file", package, file)
                break

        for pkg, file in class_html_files:
            #print("Parsing html", str(file))
            tree = ET.parse(file)
            root = tree.getroot()
            xmlns = lambda sym: "{http://www.w3.org/1999/xhtml}" + sym
            for tr in root.find(xmlns('body')).find(xmlns('table')).find(xmlns('tbody')).findall(xmlns('tr')):
                tds        = tr.findall(xmlns('td'))
                a_name     = tds[0].find(xmlns('a'))    # Used when .java.html exists (if source was available).
                s_name     = tds[0].find(xmlns('span')) # Used when source was not available during report generation.
                method     = (a_name if not a_name is None else s_name).text
                #i_coverage = tds[2].text
                #b_coverage = tds[4].text
                hit        = int(tds[-2].text) == 0 # 0 := hit; 1 := miss

                if hit:
                    #print("Method", method, "IC", i_coverage, "BC", b_coverage)
                    methods.add(pkg + "." + method)

        print("Found", str(len(methods)), "methods in", str(report_location))
        return methods

    def get_covered_methods(self, exec_filepath):
        path    = Path(exec_filepath)
        methods = set()
        methods_file = path.parent / 'methods.txt'
        if methods_file.exists():
            print("Loading methods file", str(methods_file))
            with open(methods_file, 'r') as f:
                for line in f:
                    methods.add(line)
        else:
            with tempfile.TemporaryDirectory() as location:
                output_location = Path(location)
                jacoco_report(exec_filepath, output_location, self.dist_location)
                methods = self._find_covered_methods(output_location / 'report')
            print("Writing methods file", str(methods_file))
            with open(methods_file, 'w') as f:
                for m in sorted(methods):
                    f.write(m + os.linesep)
        return methods

if __name__ == '__main__':
    #main()
    find_sub_suite('reports', 'jacop-4.10.0')


    # https://www.jacoco.org/jacoco/trunk/doc/cli.html
    #java -jar jacococli.jar merge [<execfiles> ...] --destfile <path> [--help] [--quiet]

    # 
    #java -jar jacococli.jar execinfo [<execfiles> ...] [--help] [--quiet]
    #
    # Excerpt:
    #
    # CLASS ID,        HITS/PROBES, CLASS NAME
    # e4edab7507c7b45b   17 of  30  org/jacop/core/Var
    #
